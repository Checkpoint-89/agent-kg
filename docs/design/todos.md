# Design TODOs

**Status:** Working notes  
**Date:** 2026-02-20

---

## Backlog

- Review `Relation` computed fields: clarify how `generic` / `specific` (and related text fields) are built, what invariants they should satisfy, and whether they should be derived vs persisted.
- Entity resolution: consider introducing an explicit mention-level embedding text (e.g. `mention_to_embed` / `_Mention.embed_text`) that can include role/relation context, instead of reusing `Entity.to_embed` (canonical) for clustering.
- Pipeline: QC (`_run_qc`) currently only logs/counts flags; discuss how to handle quality issues (e.g., block export, trigger re-extraction, or surface as a report without action).
- Pipeline: role filling (`_fill_roles_batch`) currently fetches `GraphContext` once from `documents[0].text` and reuses it for all relations in the batch; discuss whether context should be retrieved per document (or per relation) to avoid cross-document bias.
- Embeddings persistence: for nodes that have an embedding vector, also persist the exact `to_embed`/`embed_text` that was embedded (plus embedding model + version). Goal: avoid recomputing embed inputs, enable auditability/debugging, and support re-embedding strategies.
- Review property vs node modeling: when a concept should remain a node property versus becoming a dependent node (identity, multiplicity, provenance, evolution over time, and query patterns).
- Revisit the structural constraint requiring `Agent` + `Theme`: document the rationale, when it fails (e.g., stative / attribution / non-event relations), and possible v2 alternatives (configurable required roles, per-relation-type constraints, or discourse-claim modeling).
- Ontology discovery phase: on first run (no seed, empty ontology), the Arbiter receives all candidates at once with no reference frame. Consider adding a dedicated **discovery phase** before governance: extract → embed type descriptions → cluster → ask a discovery agent to refine clusters (split over-merged, merge under-merged) → output a draft `OntologySchema`. The Arbiter then handles **incremental governance** only. Decide: (A) discovery runs once at KG init only, or also on major drift; (B) covers both entity and relation types or entity only.
- Coreference resolution: entity names are currently extracted verbatim from source text (`"Entity names must match the source text exactly"`), so pronouns and definite descriptions ("the company", "it", "they") are never resolved to their named antecedents. This produces dangling or duplicate entities in the graph. Two mitigation options: (A) prompt-level — instruct the extraction LLM to resolve coreferences inline before populating entity names; (B) pre-processing — run a dedicated coreference pass over the full document before chunking, replacing anaphors with resolved names. Option B is more reliable but adds cost and a dependency.
- Ontology type splitting (undetected sub-type divergence): the current drift signal and `_collect_candidates` filter are blind to **intra-type bimodality**. If new relations are semantically close enough to an existing type (passing the embedding filter), they are silently mapped to it — even if they form a distinct sub-cluster that would justify splitting the type. Detection would require periodically analysing the **internal embedding distribution** of relations mapped to each type (e.g., agglomerative clustering per type, silhouette score) across accumulated graph data, then surfacing candidate splits to the Arbiter with a new `split_type` decision tool. This is a post-ingestion, graph-level operation — not a per-batch concern.
- Ontology merge scan (reverse of type splitting): the Arbiter's `merge_with_existing` tool only fires when a new candidate arrives. There is no periodic scan to detect that two **existing** ontology types have converged and should be merged. A merge scan would embed all type definitions, cluster them, and flag high-similarity pairs with overlapping relation populations. See `relation_granularity.md`.
- Atomic decomposition enforcement: there is no check that an extracted relation is "atomic" (one event/fact). Compound sentences can produce "fat" relation nodes that pack multiple facts into a single instance. Mitigation options: prompt engineering, post-extraction validation (flag compound text spans), or a dedicated decomposition agent pass. See `relation_granularity.md`.
